#!/usr/bin/env python3
"""
TCP 프록시 서버 관리 도구

프록시 서버의 연결을 조회하고 관리합니다.
"""

import socket
import struct
import sys
import argparse
from datetime import datetime
import signal

# 제어 소켓 경로
DEFAULT_SOCKET_PATH = "/tmp/tcp_proxy_control.sock"

# 명령 타입
CMD_LIST_CONNECTIONS = 0
CMD_KILL_CONNECTION = 1
CMD_SEND_SIGNAL = 2
CMD_GET_STATS = 3
CMD_SHUTDOWN = 4

# 시그널 매핑
SIGNAL_MAP = {
    'TERM': signal.SIGTERM,
    'SIGTERM': signal.SIGTERM,
    'KILL': signal.SIGKILL,
    'SIGKILL': signal.SIGKILL,
    'STOP': signal.SIGSTOP,
    'SIGSTOP': signal.SIGSTOP,
    'CONT': signal.SIGCONT,
    'SIGCONT': signal.SIGCONT,
    'HUP': signal.SIGHUP,
    'SIGHUP': signal.SIGHUP,
    'USR1': signal.SIGUSR1,
    'SIGUSR1': signal.SIGUSR1,
    'USR2': signal.SIGUSR2,
    'SIGUSR2': signal.SIGUSR2,
}


def format_bytes(bytes_val):
    """바이트를 읽기 쉬운 형식으로 변환"""
    for unit in ['B', 'KB', 'MB', 'GB']:
        if bytes_val < 1024.0:
            return f"{bytes_val:.2f} {unit}"
        bytes_val /= 1024.0
    return f"{bytes_val:.2f} TB"


def format_time(timestamp):
    """타임스탬프를 읽기 쉬운 형식으로 변환"""
    try:
        dt = datetime.fromtimestamp(timestamp)
        return dt.strftime('%Y-%m-%d %H:%M:%S')
    except:
        return "N/A"


def format_duration(seconds):
    """초를 읽기 쉬운 형식으로 변환"""
    if seconds < 60:
        return f"{seconds}초"
    elif seconds < 3600:
        return f"{seconds//60}분 {seconds%60}초"
    else:
        hours = seconds // 3600
        minutes = (seconds % 3600) // 60
        return f"{hours}시간 {minutes}분"


def send_request(socket_path, cmd, target_pid=0, signal_num=0):
    """제어 요청 전송"""
    try:
        # Unix 소켓 연결
        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        sock.connect(socket_path)

        # 요청 패킹
        request = struct.pack('iii', cmd, target_pid, signal_num)
        sock.sendall(request)

        # 응답 수신
        header_data = sock.recv(8)
        if len(header_data) < 8:
            print("응답 수신 실패")
            return None

        success = struct.unpack('?', header_data[0:1])[0]
        connection_count = struct.unpack('i', header_data[4:8])[0]

        # ConnectionInfo 구조체 크기: 172 bytes
        connection_info_size = 172
        connections_data_size = connection_info_size * 100

        # 연결 정보 수신
        connections_data = b''
        remaining = connections_data_size
        while remaining > 0:
            chunk = sock.recv(remaining)
            if not chunk:
                break
            connections_data += chunk
            remaining -= len(chunk)

        # 메시지 수신
        message_data = sock.recv(256)
        message = message_data.rstrip(b'\x00').decode('utf-8', errors='ignore')

        sock.close()

        # 연결 정보 파싱
        connections = []
        for i in range(connection_count):
            offset = i * connection_info_size
            conn_data = connections_data[offset:offset + connection_info_size]

            if len(conn_data) < connection_info_size:
                break

            pid = struct.unpack('i', conn_data[0:4])[0]
            client_addr = conn_data[4:68].rstrip(b'\x00').decode('utf-8', errors='ignore')
            client_port = struct.unpack('i', conn_data[68:72])[0]
            target_addr = conn_data[72:136].rstrip(b'\x00').decode('utf-8', errors='ignore')
            target_port = struct.unpack('i', conn_data[136:140])[0]
            c2s_bytes = struct.unpack('Q', conn_data[140:148])[0]
            s2c_bytes = struct.unpack('Q', conn_data[148:156])[0]
            start_time = struct.unpack('q', conn_data[156:164])[0]
            last_activity = struct.unpack('q', conn_data[164:172])[0]

            connections.append({
                'pid': pid,
                'client_addr': client_addr,
                'client_port': client_port,
                'target_addr': target_addr,
                'target_port': target_port,
                'c2s_bytes': c2s_bytes,
                's2c_bytes': s2c_bytes,
                'start_time': start_time,
                'last_activity': last_activity,
            })

        return {
            'success': success,
            'connection_count': connection_count,
            'connections': connections,
            'message': message
        }

    except FileNotFoundError:
        print(f"오류: 제어 소켓을 찾을 수 없습니다: {socket_path}")
        print("프록시 서버가 실행 중인지 확인하세요.")
        return None
    except Exception as e:
        print(f"오류: {e}")
        import traceback
        traceback.print_exc()
        return None


def cmd_list(args):
    """연결 목록 조회"""
    response = send_request(args.socket, CMD_LIST_CONNECTIONS)

    if not response:
        return 1

    if not response['success']:
        print(f"실패: {response['message']}")
        return 1

    connections = response['connections']

    if not connections:
        print("활성 연결이 없습니다.")
        return 0

    print(f"\n총 {len(connections)}개의 활성 연결:\n")
    print(f"{'PID':<8} {'클라이언트':<22} {'대상 서버':<22} {'업로드':<12} {'다운로드':<12} {'연결 시간':<12} {'마지막 활동'}")
    print("=" * 120)

    now = datetime.now().timestamp()

    for conn in connections:
        duration = int(now - conn['start_time'])
        last_activity = int(now - conn['last_activity'])

        client_str = f"{conn['client_addr']}:{conn['client_port']}"
        target_str = f"{conn['target_addr']}:{conn['target_port']}"
        upload_str = format_bytes(conn['c2s_bytes'])
        download_str = format_bytes(conn['s2c_bytes'])
        duration_str = format_duration(duration)
        activity_str = f"{last_activity}초 전" if last_activity < 60 else format_duration(last_activity)

        print(f"{conn['pid']:<8} {client_str:<22} {target_str:<22} {upload_str:<12} {download_str:<12} {duration_str:<12} {activity_str}")

    return 0


def cmd_kill(args):
    """특정 연결 종료"""
    response = send_request(args.socket, CMD_KILL_CONNECTION, target_pid=args.pid)

    if not response:
        return 1

    if response['success']:
        print(f"성공: {response['message']}")
        return 0
    else:
        print(f"실패: {response['message']}")
        return 1


def cmd_signal(args):
    """특정 연결에 시그널 전송"""
    signal_num = args.signal

    if isinstance(signal_num, str):
        signal_name = signal_num.upper()
        if signal_name not in SIGNAL_MAP:
            print(f"오류: 알 수 없는 시그널: {signal_num}")
            print(f"사용 가능한 시그널: {', '.join(SIGNAL_MAP.keys())}")
            return 1
        signal_num = SIGNAL_MAP[signal_name]
    else:
        signal_num = int(signal_num)

    response = send_request(args.socket, CMD_SEND_SIGNAL, target_pid=args.pid, signal_num=signal_num)

    if not response:
        return 1

    if response['success']:
        print(f"성공: {response['message']}")
        return 0
    else:
        print(f"실패: {response['message']}")
        return 1


def cmd_stats(args):
    """통계 정보 조회"""
    response = send_request(args.socket, CMD_GET_STATS)

    if not response:
        return 1

    if not response['success']:
        print(f"실패: {response['message']}")
        return 1

    connections = response['connections']

    if not connections:
        print("활성 연결이 없습니다.")
        return 0

    total_c2s = sum(conn['c2s_bytes'] for conn in connections)
    total_s2c = sum(conn['s2c_bytes'] for conn in connections)
    total_bytes = total_c2s + total_s2c

    print("\n=== 프록시 서버 통계 ===\n")
    print(f"활성 연결 수: {len(connections)}")
    print(f"총 업로드 (클라이언트→서버): {format_bytes(total_c2s)}")
    print(f"총 다운로드 (서버→클라이언트): {format_bytes(total_s2c)}")
    print(f"총 데이터 전송량: {format_bytes(total_bytes)}")

    return 0


def cmd_shutdown(args):
    """프록시 서버 종료"""
    confirm = input("프록시 서버를 종료하시겠습니까? (yes/no): ")
    if confirm.lower() not in ['yes', 'y']:
        print("취소되었습니다.")
        return 0

    response = send_request(args.socket, CMD_SHUTDOWN)

    if not response:
        return 1

    if response['success']:
        print(f"성공: {response['message']}")
        return 0
    else:
        print(f"실패: {response['message']}")
        return 1


def main():
    parser = argparse.ArgumentParser(
        description='TCP 프록시 서버 관리 도구',
        formatter_class=argparse.RawDescriptionHelpFormatter
    )

    parser.add_argument('-s', '--socket', default=DEFAULT_SOCKET_PATH,
                        help=f'제어 소켓 경로 (기본값: {DEFAULT_SOCKET_PATH})')

    subparsers = parser.add_subparsers(dest='command', help='명령어')

    # list 명령
    parser_list = subparsers.add_parser('list', aliases=['ls'], help='활성 연결 목록 조회')
    parser_list.set_defaults(func=cmd_list)

    # kill 명령
    parser_kill = subparsers.add_parser('kill', help='특정 연결 종료')
    parser_kill.add_argument('pid', type=int, help='종료할 연결의 PID')
    parser_kill.set_defaults(func=cmd_kill)

    # signal 명령
    parser_signal = subparsers.add_parser('signal', aliases=['sig'], help='특정 연결에 시그널 전송')
    parser_signal.add_argument('pid', type=int, help='대상 PID')
    parser_signal.add_argument('signal', help='시그널 번호 또는 이름 (예: TERM, STOP, CONT)')
    parser_signal.set_defaults(func=cmd_signal)

    # stats 명령
    parser_stats = subparsers.add_parser('stats', help='통계 정보 조회')
    parser_stats.set_defaults(func=cmd_stats)

    # shutdown 명령
    parser_shutdown = subparsers.add_parser('shutdown', help='프록시 서버 종료')
    parser_shutdown.set_defaults(func=cmd_shutdown)

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        return 1

    return args.func(args)


if __name__ == '__main__':
    sys.exit(main())
