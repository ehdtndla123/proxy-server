# TCP 프록시 서버

확장 가능하고 유지보수가 쉬운 TCP 프록시 서버입니다.

## 특징

✅ **양방향 TCP 프록시** - 클라이언트와 서버 사이의 투명한 중계
✅ **필터 체인** - 지연, 드롭, 쓰로틀링 필터 지원
✅ **상세한 로깅** - 컬러 콘솔 + 파일 로그
✅ **연결 통계** - 방향별 전송/수신 바이트, 패킷 수, 드롭률
✅ **멀티 클라이언트** - fork()를 통한 동시 연결 처리
✅ **설정 파일** - 유연한 설정 관리
✅ **실시간 관리** - 연결 조회, 종료, 시그널 전송 기능
✅ **보안 강화** - 입력 검증, 안전한 문자열 처리, getaddrinfo 사용
✅ **깔끔한 구조** - 모듈화된 코드 구조

## v2.0 주요 개선 사항

### 🔒 보안 강화
- `strcpy` → `strncpy`로 버퍼 오버플로우 방지
- `gethostbyname` → `getaddrinfo`로 IPv6 지원 및 스레드 안전성 향상
- 모든 명령줄 인자에 대한 입력 검증 강화 (`strtol`, `strtod` 사용)
- 포트 번호 범위 검증 (1-65535)

### 🚀 성능 및 안정성
- 부분 전송(Partial Send) 처리 추가 - 모든 데이터가 전송될 때까지 반복
- EINTR 시그널 인터럽트 재시도 처리
- 개선된 SIGCHLD 핸들러로 좀비 프로세스 완벽 방지
- `sig_atomic_t`를 사용한 안전한 시그널 처리

### 📊 통계 개선
- 방향별 통계 추적 (클라이언트→서버, 서버→클라이언트)
- 각 방향별 드롭 패킷 카운트
- 더 상세한 연결 정보 제공

### 🎛️ 실시간 관리 기능 (NEW!)
- **연결 목록 조회** - 모든 활성 연결의 실시간 상태 확인
- **개별 연결 제어** - 특정 연결 종료 또는 시그널 전송
- **통계 조회** - 전체 프록시 서버 통계 요약
- Unix Socket 기반 IPC로 관리 명령 처리

### 🔧 코드 품질
- 매직 넘버 제거 및 상수화
- 더 명확한 에러 메시지
- 컴파일 경고 최소화

## 디렉토리 구조

```
tcp_proxy/
├── src/              # 소스 코드
│   ├── main.c        # 메인 프로그램
│   ├── proxy.c       # 프록시 코어
│   ├── logger.c      # 로깅 시스템
│   ├── filter.c      # 필터 체인
│   ├── config.c      # 설정 관리
│   └── control.c     # 제어 서버 (NEW!)
├── include/          # 헤더 파일
│   ├── types.h       # 공통 타입 정의
│   ├── proxy.h
│   ├── logger.h
│   ├── filter.h
│   ├── config.h
│   └── control.h     # 제어 서버 (NEW!)
├── bin/              # 실행 파일
│   ├── tcp_proxy     # 프록시 서버
│   └── proxyctl      # 관리 도구 (NEW!)
├── config/           # 설정 파일
│   ├── proxy.conf    # 기본 설정
│   └── db_proxy.conf # DB 프록시 설정
├── logs/             # 로그 파일
├── build/            # 빌드 파일 (자동 생성)
├── MANAGEMENT.md     # 관리 도구 가이드 (NEW!)
└── Makefile          # 빌드 스크립트
```

## 빌드

```bash
cd tcp_proxy
make
```

빌드 후 `bin/tcp_proxy` 실행 파일이 생성됩니다.

## 사용법

### 기본 실행

```bash
# 기본 설정으로 실행 (9999 -> 127.0.0.1:8080)
./bin/tcp_proxy

# 포트 지정
./bin/tcp_proxy -p 9999 -t 127.0.0.1:8080

# 설정 파일 사용
./bin/tcp_proxy -c config/proxy.conf
```

### 옵션

```
-p <port>       리스닝 포트 (기본값: 9999)
-t <host:port>  대상 서버 (기본값: 127.0.0.1:8080)
-c <file>       설정 파일 경로
-l <file>       로그 파일 경로 (기본값: logs/proxy.log)
-d <ms>         지연 필터 추가 (밀리초)
-r <rate>       드롭 필터 추가 (0.0~1.0)
-b <bytes/s>    쓰로틀 필터 추가
-v              디버그 모드
-h              도움말
```

### 필터 예시

```bash
# 100ms 지연 추가
./bin/tcp_proxy -p 9999 -t 127.0.0.1:8080 -d 100

# 10% 패킷 드롭
./bin/tcp_proxy -p 9999 -t 127.0.0.1:8080 -r 0.1

# 1KB/s로 대역폭 제한
./bin/tcp_proxy -p 9999 -t 127.0.0.1:8080 -b 1024

# 여러 필터 조합
./bin/tcp_proxy -p 9999 -t 127.0.0.1:8080 -d 50 -r 0.05 -b 10240
```

## 사용 시나리오

### 프록시 종료 방법

**방법 1: Ctrl+C (권장)**
```bash
# 프록시 실행 중인 터미널에서
Ctrl+C
# 깔끔하게 종료됩니다
```

**방법 2: 종료 스크립트**
```bash
./kill_proxy.sh
# 실행 중인 모든 프록시 프로세스 종료
```

**방법 3: 관리 도구 사용 (권장)**
```bash
# 프록시 서버 종료
./bin/proxyctl shutdown

# 또는 특정 연결만 종료
./bin/proxyctl list        # 연결 목록 확인
./bin/proxyctl kill <PID>  # 특정 연결 종료
```

**방법 4: 수동 종료**
```bash
# 프로세스 찾기
ps aux | grep tcp_proxy

# 종료
kill -TERM <PID>

# 또는 강제 종료
killall -9 tcp_proxy
```

## 🎛️ 관리 기능

프록시 서버 실행 중 `proxyctl` 도구를 사용하여 실시간으로 연결을 관리할 수 있습니다.

### 활성 연결 목록 조회

```bash
./bin/proxyctl list
```

**출력 예시:**
```
총 3개의 활성 연결:

PID      클라이언트            대상 서버            업로드       다운로드     연결 시간    마지막 활동
========================================================================================================================
12345    192.168.1.100:54321   127.0.0.1:8080      15.32 KB    102.45 KB   2분 30초    5초 전
12346    192.168.1.101:54322   127.0.0.1:8080      8.91 KB     45.67 KB    1분 15초    2초 전
```

### 특정 연결 종료

```bash
./bin/proxyctl kill 12345
```

### 통계 정보 조회

```bash
./bin/proxyctl stats
```

**출력 예시:**
```
=== 프록시 서버 통계 ===

활성 연결 수: 3
총 업로드 (클라이언트→서버): 49.66 KB
총 다운로드 (서버→클라이언트): 346.44 KB
총 데이터 전송량: 396.10 KB
```

### 시그널 전송

특정 연결에 시그널을 전송할 수 있습니다.

```bash
# 연결 일시 정지
./bin/proxyctl signal 12345 STOP

# 연결 재개
./bin/proxyctl signal 12345 CONT

# 커스텀 시그널
./bin/proxyctl signal 12345 USR1
```

**사용 가능한 시그널:** TERM, KILL, STOP, CONT, HUP, USR1, USR2

### 실시간 모니터링

`watch` 명령과 함께 사용하여 실시간 모니터링이 가능합니다.

```bash
# 2초마다 연결 목록 갱신
watch -n 2 './bin/proxyctl list'

# 5초마다 통계 갱신
watch -n 5 './bin/proxyctl stats'
```

> 📖 **자세한 내용은 [MANAGEMENT.md](MANAGEMENT.md)를 참고하세요.**

## 사용 시나리오

### 1. 서버2 프록시

```bash
# 서버2가 8080 포트에서 실행 중
./bin/tcp_proxy -p 9999 -t 127.0.0.1:8080

# 서버1에서 프록시로 연결
# connect(sock, "프록시주소", 9999)
```

### 2. DB 프록시

```bash
# MySQL DB가 3306 포트에서 실행 중
./bin/tcp_proxy -p 10000 -t 127.0.0.1:3306 -c config/db_proxy.conf

# 또는 명령행으로
./bin/tcp_proxy -p 10000 -t db.example.com:3306

# 서버1에서 DB 프록시로 연결
# mysql_connect(..., "프록시주소", 10000)
```

### 3. 동시에 여러 프록시 실행

```bash
# 터미널 1: 서버2 프록시
./bin/tcp_proxy -p 9999 -t 127.0.0.1:8080 -l logs/server2.log

# 터미널 2: DB 프록시
./bin/tcp_proxy -p 10000 -t 127.0.0.1:3306 -l logs/db.log
```

### 4. 네트워크 시뮬레이션

```bash
# 느린 네트워크 시뮬레이션 (100ms 지연 + 5% 패킷 손실)
./bin/tcp_proxy -p 9999 -t real-server:8080 -d 100 -r 0.05

# 낮은 대역폭 시뮬레이션
./bin/tcp_proxy -p 9999 -t real-server:8080 -b 51200  # 50KB/s
```

## 로그 예시

```
[INFO] [2025-10-30 15:30:45] TCP 프록시 서버 v1.0
[INFO] [2025-10-30 15:30:45] === 프록시 설정 ===
[INFO] [2025-10-30 15:30:45]   리스닝 포트: 9999
[INFO] [2025-10-30 15:30:45]   대상 서버: 127.0.0.1:8080
[INFO] [2025-10-30 15:30:45]   로깅: 활성화
[INFO] [2025-10-30 15:30:45]   로그 파일: logs/proxy.log
[INFO] [2025-10-30 15:30:45]   필터: 활성화
[INFO] [2025-10-30 15:30:45] === 필터 체인 (2개) ===
[INFO] [2025-10-30 15:30:45]   [0] 지연: 100 ms
[INFO] [2025-10-30 15:30:45]   [1] 드롭: 10.00%
[INFO] [2025-10-30 15:30:45] ======================================
[INFO] [2025-10-30 15:30:45] 프록시 서버 시작
[INFO] [2025-10-30 15:30:45] 리스닝: 0.0.0.0:9999
[INFO] [2025-10-30 15:30:45] 대상: 127.0.0.1:8080
[INFO] [2025-10-30 15:30:45] ======================================
[INFO] [2025-10-30 15:30:50] 새 클라이언트 연결: 127.0.0.1:54321
[INFO] [2025-10-30 15:30:50] 대상 서버 연결 성공: 127.0.0.1:8080
[DEBUG] [2025-10-30 15:30:51] 클라이언트 → 서버: 1024 bytes
[DEBUG] [2025-10-30 15:30:51] 지연 적용: 100 ms
[WARN] [2025-10-30 15:30:52] 패킷 드롭 (확률: 10.00%, 랜덤: 8.35)
[INFO] [2025-10-30 15:31:00] === 연결 통계 ===
[INFO] [2025-10-30 15:31:00]   전송: 102400 bytes (100 packets)
[INFO] [2025-10-30 15:31:00]   수신: 51200 bytes (50 packets)
[INFO] [2025-10-30 15:31:00]   드롭: 5 packets
[INFO] [2025-10-30 15:31:00]   연결 시간: 10 초
[INFO] [2025-10-30 15:31:00]   평균 전송률: 10.00 KB/s
[INFO] [2025-10-30 15:31:00]   평균 수신률: 5.00 KB/s
```

## 설정 파일 형식

```ini
# 주석은 #으로 시작
listen_port=9999
target_host=127.0.0.1
target_port=8080
enable_logging=true
log_file=logs/proxy.log
enable_filters=false
```

## 코드 확장하기

### 새로운 필터 추가

1. `include/types.h`에 필터 타입 추가
2. `src/filter.c`에 필터 로직 구현
3. `src/main.c`에 명령행 옵션 추가

### 프로토콜별 처리

현재는 TCP 바이트 스트림을 그대로 전달하지만, 특정 프로토콜(HTTP, MySQL 등)을 파싱하여 처리하고 싶다면:

1. `src/protocol.c` 파일 생성
2. 프로토콜 파서 구현
3. `proxy.c`에서 필터 적용 전에 파싱

## 문제 해결

### 포트가 이미 사용 중

```bash
# 포트 사용 중인 프로세스 확인
lsof -i :9999

# 프로세스 종료
kill -9 <PID>
```

### 로그 파일 권한 오류

```bash
# logs 디렉토리 권한 확인
chmod 755 logs/
```

### 좀비 프로세스

프로그램이 SIGCHLD를 처리하므로 자동으로 정리됩니다.

## 성능 최적화

- `BUFFER_SIZE` 조정: `src/proxy.c`에서 8192에서 더 크게
- 단일 프로세스 멀티플렉싱: fork 대신 epoll 사용
- Zero-copy: splice() 시스템 콜 사용

## 라이선스

MIT License

## 기여

이슈와 PR은 언제나 환영합니다!
